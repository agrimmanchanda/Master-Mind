#include <iostream>
#include <cstdlib>
#include <ctime>
#include <vector>
#include <cmath>
#include <string>

/// functions for random number generation, do not alter the declarations
void set_random_seed();
int randn(int n);
void give_learn_feedback(const std::vector<int> sequence, const std::vector<int>& attempt, int& black_hits, int& white_hits, int length);
void PermutationList(int n, int length, std::vector<std::vector<int>>& p_list, std::vector<int>& solution_list);
int MaxParts(const std::vector<std::vector<int>>& possible_solutions, const std::vector<int>& best_next_attempt, int num, int length);

/// this is the struct definition for the code maker
struct mm_code_maker{

    /// this member function sets the values for the member data
    /// representing the lenght of the code
    /// and the number of symbols (the symbols will be 0 to i_num)
    /// (this should be a constructor in proper OOP but ok)
    void init(int i_length, int i_num){
        length = i_length;
        num = i_num;
    }

    /// this member function generates a random sequence based
    /// on the length and num parameters stored as member data
    void generate_sequence(){
        for(int i = 0; i < length; i++){
            sequence.push_back(randn(num));
        }
    }

		void give_feedback(const std::vector<int>& attempt, int& black_hits, int& white_hits){
			black_hits = 0;
			white_hits = 0;

			std::vector<int> vtemp_seq;
			std::vector<int> vtemp_attempt;
			for(int i = 0; i < length; i++){
					vtemp_seq.push_back(sequence[i]);
					vtemp_attempt.push_back(attempt[i]);
			}

			for (int i = 0; i < length; i++){
				if(vtemp_seq[i] == vtemp_attempt[i] && vtemp_attempt[i] >= 0){
					black_hits++;
					vtemp_seq[i] = -1;
					vtemp_attempt[i] = -2;
				}
			}

			for (int i = 0; i < length; i++){
				for(int j = 0; j < length; j++){
					if(vtemp_seq[i] == vtemp_attempt[j] && vtemp_attempt[j] >= 0){
						white_hits++;
						vtemp_seq[i] = -1;
						vtemp_attempt[j] = -2;
					}
				}
			}
	  }



    /// member data holding the sequence generated by generate_sequence
    std::vector<int> sequence;

    /// member data holding the values for length of code and number of symbols
    int length;
    int num;
};


/// this is the struct definition for the solver
struct mm_solver{

    /// this member function sets the values for the member data
    /// representing the lenght of the code
    /// and the number of symbols (the symbols will be 0 to i_num)
    /// (this should be a constructor in proper OOP but ok)
    void init(int i_length, int i_num){
        length = i_length;
        num = i_num;
        std::vector<int> solution_list;
        PermutationList(num, length, possible_solutions, solution_list);
    }

    /// this member function creates an attempt to find the right code
    /// (see the other examples provided for clarifications)
    void create_attempt(std::vector<int>& attempt){

      int max_partition=0;
			int next_attempt;
      int partition;
			int total_size = std::pow(num, length);
			if(possible_solutions.size() == total_size){
        for (int i = 0; i < length/2; i++){
            attempt.push_back(0);
        }
        while (attempt.size() < length-1){
            attempt.push_back(1);
        }
        attempt.push_back(2);
      }

      else if(possible_solutions.size() <= 2025){
				for (int i=0; i < possible_solutions.size(); i++){
					partition = MaxParts(possible_solutions, possible_solutions[i], num, length);
					if(partition > max_partition){
					max_partition = partition;
					next_attempt = i;
					}
				}
			  attempt = possible_solutions[next_attempt];
			}

			else{
				set_random_seed();
				int random_index = randn(possible_solutions.size());
				std::vector<int>random_attempt = possible_solutions[random_index];

				for (int i = 0; i < length; i++){
						attempt.push_back(random_attempt[i]);
				}
			}
  	}

    /// this member function acquires the feedback about a certain attempt
    /// (see the other examples provided for clarifications)
    void learn(std::vector<int>& attempt, int black_hits, int white_hits){
				int bh = 0;
        int wh = 0;
        std::vector<std::vector<int>> new_possible_solutions;
        for (int i = 0; i < possible_solutions.size(); i++){
            give_learn_feedback(attempt, possible_solutions[i], bh, wh, length);
            if(black_hits == bh && white_hits == wh)
                new_possible_solutions.push_back(possible_solutions[i]);
        }

        possible_solutions = new_possible_solutions;
		}



    int length;
    int num;
    std::vector<std::vector<int>>possible_solutions;
};

int main(){
    /// our program uses random features so we need to call the function setting a random seed
    set_random_seed();

    int length, num;
    std::cout << "enter length of sequence and number of possible values:" << std::endl;
    std::cin >> length >> num;
    double sum = 0;
    double times = 0;
    clock_t tStart = clock();

    while(times < 50){

        mm_solver solver;
        /// we declare an object of type mm_solver

        solver.init(length, num);
        /// we initialise the values for length and num

        mm_code_maker maker;
        /// we declare an object of type mm_code_maker

        maker.init(length, num);
        /// we initialise the values for length and num

        maker.generate_sequence();

        int black_hits = 0, white_hits = 0;
        /// just some number to limit the number of attempts
        int attempts_limit = 2000000;
        int attempts = 0;
        while((black_hits < length) && (attempts < attempts_limit)){

            std::vector<int> attempt;
            solver.create_attempt(attempt);


            /// the solver creates an attempt

            maker.give_feedback(attempt, black_hits, white_hits);


            /// we print the attempt
            std::cout << "attempt: " << std::endl;
            for(int i = 0; i < attempt.size(); i++){
                std::cout << attempt[i] << " ";
            }
            std::cout << std::endl;
            /// we print the feedback
            std::cout << "black pegs: " << black_hits << " " << " white pegs: " << white_hits << std::endl;
            /// we give the feedback to the solver so that it can learn

            solver.learn(attempt, black_hits, white_hits);
            attempts++;
        }

        if(black_hits == length){
            std::cout << "the solver has found the sequence in " << attempts << " attempts" << std::endl;
        }
        else{
            std::cout << "after " << attempts << " attempts still no solution" << std::endl;
        }
        std::cout << "the sequence generated by the code maker was:" << std::endl;
        for(int i = 0; i < maker.sequence.size(); i++){
            std::cout << maker.sequence[i] << " ";
        }
        std::cout << std::endl;

        sum+= attempts;
        times++;
    }
    double average = sum/times;
    std::cout <<"after " <<times << " " <<"guesses ";
    std::cout <<"average = " <<average <<std::endl;

    printf("Time taken: %.2fs\n", (double)(clock() - tStart)/CLOCKS_PER_SEC);
    std::cout <<"time average: " <<(double)(clock() - tStart)/CLOCKS_PER_SEC/times;
    return 0;
    return 0;

}

void set_random_seed(){
    std::srand(std::time(0));
}

int randn(int n){
    return std::rand() % n;
}


/// other functions for program function

void PermutationList(int n, int length, std::vector<std::vector<int>>& p_list, std::vector<int>& solution_list){
    if(solution_list.size() < length){
        for(int i = 0; i < n; i++){
            solution_list.push_back(i);
            PermutationList(n, length, p_list, solution_list);
            solution_list.pop_back();
        }
    }
    else{
        p_list.push_back(solution_list);
    }
}

void give_learn_feedback(const std::vector<int>sequence, const std::vector<int>& attempt,int& black_hits, int& white_hits, int length){
			black_hits = 0;
			white_hits = 0;

			std::vector<int> vtemp_seq;
			std::vector<int> vtemp_attempt;
			for(int i = 0; i < length; i++){
					vtemp_seq.push_back(sequence[i]);
					vtemp_attempt.push_back(attempt[i]);
			}

			for (int i = 0; i < length; i++){
				if(vtemp_seq[i] == vtemp_attempt[i] && vtemp_attempt[i] >= 0){
					black_hits++;
					vtemp_seq[i] = -1;
					vtemp_attempt[i] = -2;
				}
			}

			for (int i = 0; i < length; i++){
				for(int j = 0; j < length; j++){
					if(vtemp_seq[i] == vtemp_attempt[j] && vtemp_attempt[j] >= 0){
						white_hits++;
						vtemp_seq[i] = -1;
						vtemp_attempt[j] = -2;
					}
				}
      }
}

int MaxParts(const std::vector<std::vector<int>>& possible_solutions, const std::vector<int>& best_next_attempt, int num, int length){

  std::vector<int> vtemp_partition;
  int total_size = std::pow(num, length);
  for(int i = 0; i < total_size; i++){
    vtemp_partition.push_back(0);
  }

  int b_hit;
  int w_hit;
  int partition = 0;
	for(int i=0; i < possible_solutions.size(); i++){
		give_learn_feedback(best_next_attempt, possible_solutions[i], b_hit, w_hit, length);
		int table = w_hit + b_hit*(num);
		if(vtemp_partition[table] == 0){
        partition++;
        vtemp_partition[table] = -1;
		}
	}
	return partition;
}
